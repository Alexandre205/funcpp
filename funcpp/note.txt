y a un probleme avec les stats 
|-> si on a 995 d'attaque que l'on fait plus 10 on reste à 999 puis -10 = 989
|-> donc 995 + 10 -10 = 989
|=> séparer stat réel et stat effective
|=> les variable stats peuvent dépasser le plafond de stat mais les vrais stats effectives(retourné par une fonction) seront limité	a un plafond

Est-ce que je dois faire une classe mere pour tout les équipement voir tous les objet
|-> pourrait etre pas mal pour le loot
|=> une classe item sera ajouté

Choisir quel structure de donnée utiliser pour l'inventaire
|-> array ou vector pour acces O(1) mais difficulté de suppression
|-> list ou forward_list pour l'ajout et suppression rapide mais recherche O(n)
|-> array il sera difficile de changer la taille de l'inventaire en cours de partie
|=> utiliser un array pour l'inventaire de base + les extension seront ajouter sous forme d'une list

Où mettre la Classe
|-> une dans perso et une non obligatoire dans monstre
|-> dans entite avec une classe utiliser comme sans classe

consomable.utilisation(Entite cible); ne peut pas fonctionner car Entite est une classe abstrait
|=> utiliser une reference (Entite& cible)

L'inventaire de Perso ne subissait pas les changement fait dans la classe Inventaire
|=> j'ai gardé inventaire comme static dans la classe Perso mais getInventaire renvoi un pointeur

Faire des Consommable à la main, classe par classe est trops long et tres beau
|=> utiliser des pointeur de fonction permetant d'avoir des objets de la meme classe mais avec des effets different

Je sais pas si je dois faire des classe apart pour les equipement magique
|-> plus long mais plus versatile
|-> ou bien juste mettre une variable en plus pouvant etre NULL dans les classes equipments

Comment stocker les loot des monstre pour avoir l'item et la chance de drop
|=> une map mais va falloir bucher pour bien comprendre
|=> Item est la cle pour obtenir son pourcentage de drop
:> enfaite non
|=> on fait une structure loot utilisable dans las classes Monstre contenant le pourcentage de drop de l'Item et l'Item qui va avec
|-> on garde la structure sous la forme d'un vecteur pour le moment mais voir à l'optimisation ce que ca donne

Dans la maniere dont le Effet fonctionnent ont ne peut cibler qu'une seul  entite avec
|-> chercher un equivalent de params de c#
|=> std::initializer_list<> :> non c'est que pour de truc constant
|=> vector<Entite*> car on peut passer les argument {arg1,arg2}
:> je peux pas surchager vector<Entite*> et Entite& car ambiguité de surchage
|=> il ne reste plus que utiliser(std::vector<Entite*> cibles);

Probleme entre les stat et l'équipement des équipement, les Pv et Pm sont parfois au dessus de leurs max
|=> faire passer l'équipement des équipements par la classe Perso uniquement pour pouvoir controller les stats
:> faire gaffe je crois les stat reel peuvent passer en dessous de 0 lorsqu'elle interagissent avec des equipement
|=> je pense avoir réglé le probleme

Faire une "Interface" combatable pour Certaines Entite ?
|-> Permet de faire faire la difference entre PNJ, Monstre et Perso
|-> Une sous-classe peut-etre

Comment bien faire les competences ?
-> faire une classe pricipale competence avec des classe filles specifique
-> faire une seule classe tres complete mais avec beaucoup d'abstraction :: pourquoi j'ai ecrit ca? c une idée de merde
=> formule de dégat : j'ai fait ca. Ca ma pris 3 jours bordel

L'Affichage a ete mis dans un namespace a part pour faciliter les peut-etre future modification
|-> j'ai probablement mal gérer la gestion du nom des fonctions d'affichage
|-> j'aurais du partir sur des nom plus en rapport avec l'utilite de se que la fonction affiche

Faire une interface IUsable pour tout ce qui aura besoin d'une formule de degat et d'effets pour etre utiliser
$-> obliger de mettre un destructor vide dans l'interface pour que la destruction se passe correctement
|-> Ni les Consommable ni l'Inventaire à acces au info sur le porteur
|=> Avec l'implemtation de IUsable j'ai été forcé de rajouter un posseur pour les consommables

Comment gérer fight.isFinished()
|-> renvoie un simple booléen pour determiner si le combat est finis
|-> renvoie une classe finDeCombat avec de info sur la fin du combat
|-> gérer l'entiereté du coombat avec une structure sur se qui se passe dans le combat

Comment gérer les morts pendant un combat 
|-> Les laisser comme cadavre : permetrait de les faire raise
|-> Les faire disparaitre : laisse de l'espace pour pouvoir y mettre des nouveaux monstres pendant le combat
|=> On part sur pas de raise

La gestion des Monstres dans les Fight est bizzare
|-> quand tu passe par copie des objets les pointeur sont nullifier pour eviter les erreurs
|=> faut les passer par des pointeur

Où mettre l'obtention des competences par l'utilisateur
|->séparer en 2 > on obtiens la competence > en fonction de la competence on choisit les/la cibles(s)
	comme ça on peut faire de la séléction variant en fonction de la competence
|-> faire une enum dans Compentence pour gérer le ciblage :>mono,all,self,multi

Le déroulement du combat devra etre revu pour intégrer les differents ciblage ainsi que la priorité des competences
